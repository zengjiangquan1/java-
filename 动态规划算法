动态规划（Dynamic Programming, DP）是一种通过将复杂问题分解成更小的子问题来求解问题的算法设计方法。动态规划适用于那些具有**重叠子问题**和**最优子结构**性质的问题。以下是动态规划的一些经典例子，以及动态规划的思想说明。

### 动态规划思想说明

1. **最优子结构**：问题的最优解包含其子问题的最优解。
2. **重叠子问题**：子问题在求解过程中会被多次求解。
3. **记忆化搜索**：通过存储已经计算过的子问题的结果来避免重复计算，从而提高效率。
4. **状态转移方程**：通过递推公式或状态转移方程来描述状态之间的关系。

### 经典动态规划例子

#### 1. 斐波那契数列

求第 \( n \) 个斐波那契数。

**状态转移方程**：
\[ F(n) = F(n-1) + F(n-2) \]
\[ F(0) = 0, F(1) = 1 \]

**代码实现**：
```java
public int fibonacci(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n+1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

#### 2. 最长公共子序列（LCS）

求两个字符串的最长公共子序列。

**状态转移方程**：
\[ dp[i][j] = dp[i-1][j-1] + 1 \quad (text1[i-1] == text2[j-1]) \]
\[ dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) \quad (text1[i-1] \neq text2[j-1]) \]

**代码实现**：
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m+1][n+1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i-1) == text2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```

#### 3. 背包问题

在给定重量限制下，求能够取得的最大价值。

**状态转移方程**：
\[ dp[i][w] = \max(dp[i-1][w], dp[i-1][w - weight[i-1]] + value[i-1]) \quad (weight[i-1] \leq w) \]

**代码实现**：
```java
public int knapsack(int W, int[] weight, int[] value) {
    int n = weight.length;
    int[][] dp = new int[n+1][W+1];
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (weight[i-1] <= w) {
                dp[i][w] = Math.max(dp[i-1][w], dp[i-1][w - weight[i-1]] + value[i-1]);
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }
    return dp[n][W];
}
```

#### 4. 最小路径和

在一个矩阵中，从左上角走到右下角，每一步只能向下或向右，求最小路径和。

**状态转移方程**：
\[ dp[i][j] = grid[i][j] + \min(dp[i-1][j], dp[i][j-1]) \]

**代码实现**：
```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0];
    }
    for (int j = 1; j < n; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j];
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
        }
    }
    return dp[m-1][n-1];
}
```

#### 5. 编辑距离

求将一个字符串转换为另一个字符串所需的最小操作次数。

**状态转移方程**：
\[ dp[i][j] = dp[i-1][j-1] \quad (word1[i-1] == word2[j-1]) \]
\[ dp[i][j] = \min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 \quad (word1[i-1] \neq word2[j-1]) \]

**代码实现**：
```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    int[][] dp = new int[m+1][n+1];
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i-1) == word2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
            }
        }
    }
    return dp[m][n];
}
```

#### 6. 乘积最大子数组

求一个数组中乘积最大的连续子数组。

**状态转移方程**：
\[ dpMax[i] = \max(nums[i], dpMax[i-1] \times nums[i], dpMin[i-1] \times nums[i]) \]
\[ dpMin[i] = \min(nums[i], dpMax[i-1] \times nums[i], dpMin[i-1] \times nums[i]) \]

**代码实现**：
```java
public int maxProduct(int[] nums) {
    if (nums.length == 0) return 0;
    int maxProduct = nums[0];
    int dpMax = nums[0], dpMin = nums[0];
    for (int i = 1; i < nums.length; i++) {
        int tempMax = dpMax;
        dpMax = Math.max(Math.max(dpMax * nums[i], dpMin * nums[i]), nums[i]);
        dpMin = Math.min(Math.min(tempMax * nums[i], dpMin * nums[i]), nums[i]);
        maxProduct = Math.max(maxProduct, dpMax);
    }
    return maxProduct;
}
```

### 总结

动态规划是一种通过记忆化搜索和状态转移方程来解决复杂问题的有效方法。它适用于那些具有最优子结构和重叠子问题性质的问题。通过将问题分解成更小的子问题，并记住这些子问题的解，动态规划能够显著提高解决问题的效率。
