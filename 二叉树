1. 简介

 二叉树专题

本专题涵盖了二叉树的基本概念、种类、常见操作、遍历方法及相关的算法问题。希望通过这些内容，读者能够深入理解二叉树的相关知识，并能够熟练地解决相关的算法问题。
2. 二叉树的种类
二叉树的种类

1. 满二叉树 (Full Binary Tree)
   每个结点要么是叶子结点，要么有两个子结点。
   
2. 完全二叉树 (Complete Binary Tree)
   除了最后一层，其他层的结点都是满的，且最后一层的结点尽可能地靠左。

3. 完美二叉树 (Perfect Binary Tree)
   所有内结点都有两个子结点，所有叶子结点都在同一层。

4. 平衡二叉树 (Balanced Binary Tree)
   左右子树的高度差不超过1。

5. 搜索二叉树 (Binary Search Tree)
   左子树的结点值都小于根结点值，右子树的结点值都大于根结点值。

6. 红黑树 (Red-Black Tree)
   一种自平衡二叉查找树，具有额外的红黑属性。

7. AVL树 (AVL Tree)
   一种自平衡二叉查找树，左右子树高度差不超过1。
3. 二叉树的基本操作
二叉树的基本操作

 创建二叉树

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int x) {
        val = x;
    }
}
插入节点
java
复制代码
public TreeNode insert(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    if (val < root.val) {
        root.left = insert(root.left, val);
    } else if (val > root.val) {
        root.right = insert(root.right, val);
    }
    return root;
}
删除节点
java
复制代码
public TreeNode delete(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    if (val < root.val) {
        root.left = delete(root.left, val);
    } else if (val > root.val) {
        root.right = delete(root.right, val);
    } else {
        if (root.left == null) {
            return root.right;
        } else if (root.right == null) {
            return root.left;
        }
        TreeNode minNode = findMin(root.right);
        root.val = minNode.val;
        root.right = delete(root.right, minNode.val);
    }
    return root;
}

private TreeNode findMin(TreeNode root) {
    while (root.left != null) {
        root = root.left;
    }
    return root;
}
4. 二叉树的遍历
markdown
复制代码
## 二叉树的遍历

### 前序遍历 (Pre-order Traversal)

```java
public void preOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    System.out.print(root.val + " ");
    preOrder(root.left);
    preOrder(root.right);
}
中序遍历 (In-order Traversal)
java
复制代码
public void inOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    inOrder(root.left);
    System.out.print(root.val + " ");
    inOrder(root.right);
}
后序遍历 (Post-order Traversal)
java
复制代码
public void postOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    postOrder(root.left);
    postOrder(root.right);
    System.out.print(root.val + " ");
}
层序遍历 (Level-order Traversal)
java
复制代码
public void levelOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        System.out.print(node.val + " ");
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}
5. 常见问题和算法
markdown
复制代码
## 常见问题和算法

### 1. 二叉树的最大深度

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);
    return Math.max(leftDepth, rightDepth) + 1;
}
2. 二叉树的最小深度
java
复制代码
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null) {
        return minDepth(root.right) + 1;
    }
    if (root.right == null) {
        return minDepth(root.left) + 1;
    }
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
3. 判断二叉树是否对称
java
复制代码
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return isMirror(root.left, root.right);
}

private boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) {
        return true;
    }
    if (t1 == null || t2 == null) {
        return false;
    }
    return (t1.val == t2.val)
        && isMirror(t1.right, t2.left)
        && isMirror(t1.left, t2.right);
}
4. 计算二叉树的节点数
java
复制代码
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return 1 + countNodes(root.left) + countNodes(root.right);
}
5. 翻转二叉树
java
复制代码
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
}
更多问题将陆续添加...

6. 结论
markdown
复制代码
## 结论

通过对二叉树的学习和练习，我们可以掌握其基础知识及应用在算法题中的技巧。希望本专题能够帮助你在二叉树的学习过程中更加顺利。
